&НаСервере
Процедура ИнициализироватьХранилищеVault(ТабДок) Экспорт
    Перем АдресХранилища, ПортХранилища, HTTPСоединение, HTTPЗапрос, Ответ, ОтветJSON, СтруктураJSON, ТелоЗапроса, ОтветДанные, Ключи, RootToken, КлючиBase64;

    АдресХранилища = Константы.АдресХранилища.Получить();
    ПортХранилища = Константы.ПортХранилища.Получить();

    HTTPСоединение = Новый HTTPСоединение(АдресХранилища, Число(ПортХранилища));
    HTTPЗапрос = Новый HTTPЗапрос("/v1/sys/init");

    Ответ = HTTPСоединение.ВызватьHTTPМетод("GET", HTTPЗапрос);
    Если Ответ.КодСостояния = 200 Тогда
        ОтветJSON = Ответ.ПолучитьТелоКакСтроку();
        СтруктураJSON = Новый ЧтениеJSON;
        СтруктураJSON.УстановитьСтроку(ОтветJSON); 
        ОтветДанные = ЗаполнитьСтруктуруИзОтветаJSON(СтруктураJSON);

        Если ОтветДанные["initialized"] = Ложь Тогда
            Сообщить("Хранилище не инициализировано. Начинаем инициализацию.");
            
            ТелоЗапроса = "{""secret_shares"": 5, ""secret_threshold"": 3}";
            HTTPЗапрос = Новый HTTPЗапрос("/v1/sys/init"); 
            HTTPЗапрос.УстановитьТелоИзСтроки(ТелоЗапроса, "UTF-8");
            Ответ = HTTPСоединение.ВызватьHTTPМетод("POST", HTTPЗапрос);

            Если Ответ.КодСостояния = 200 Тогда
                Сообщить("Хранилище успешно инициализировано.");

                ОтветJSON = Ответ.ПолучитьТелоКакСтроку();
                СтруктураJSON.УстановитьСтроку(ОтветJSON); 
                ОтветДанные1 = ЗаполнитьСтруктуруИзОтветаJSON(СтруктураJSON);

                // Получаем макет для вывода данных
                ОбработкаОбъект = РеквизитФормыВЗначение("Объект");
                Макет = ОбработкаОбъект.ПолучитьМакет("ТабличныйМакет");

                // Выводим RootToken
                Если ОтветДанные1.Свойство("root_token") Тогда         
                    RootToken = ОтветДанные1["root_token"];
                    Строка = Макет.ПолучитьОбласть("Строка");
                    Строка.Параметры.Ключ = "Root Token: " + RootToken;
                    ТабДок.Вывести(Строка);
                КонецЕсли;

                // Выводим ключи
                Если ОтветДанные1.Свойство("keys") Тогда
                    Ключи = ОтветДанные1["keys"];
                    Для Каждого Ключ Из Ключи Цикл
                        Строка = Макет.ПолучитьОбласть("Строка");
                        Строка.Параметры.Ключ = "Unseal Key: " + Ключ;
                        ТабДок.Вывести(Строка);
                    КонецЦикла;
                КонецЕсли;

                // Выводим ключи Base64
                Если ОтветДанные1.Свойство("keys_base64") Тогда
                    КлючиBase64 = ОтветДанные1["keys_base64"];
                    Для Каждого Ключ Из КлючиBase64 Цикл
                        Строка = Макет.ПолучитьОбласть("Строка");
                        Строка.Параметры.Ключ = "Base64 Key: " + Ключ;
                        ТабДок.Вывести(Строка);
                    КонецЦикла;
                КонецЕсли;

            Иначе
                Сообщить("Ошибка при инициализации хранилища: " + Ответ.ТекстОтвета);
            КонецЕсли;
        Иначе
            Сообщить("Хранилище уже инициализировано.");
        КонецЕсли;
    Иначе
        Сообщить("Не удалось проверить статус хранилища. Код ответа: " + Ответ.КодСостояния);
    КонецЕсли;
КонецПроцедуры

&НаКлиенте
Процедура ПоказатьКлючиНаЭкран()
    ТабДок = Новый ТабличныйДокумент;
    ИнициализироватьХранилищеVault(ТабДок);
    ТабДок.Показать();
КонецПроцедуры

&НаКлиенте
Процедура ПоказатьТабДокумент()
    // Проверяем, если табличный документ существует
    Если ЭтотОбъект.ТабДокументДляОтображения <> Неопределено Тогда
        // Отображаем табличный документ
        ЭтотОбъект.ТабДокументДляОтображения.Показать();
    Иначе
        Сообщить("Табличный документ не был создан.");
    КонецЕсли;
КонецПроцедуры

&НаКлиенте
Процедура КнопкаПроверитьНажатие(Команда)
    // Получаем токен из параметра (или из константы)
    Токен = ПолучитьТокен();

    URL = "/v1/sys/seal-status";
    Соединение = Новый HTTPСоединение("10.0.0.11", 8200);
    
    Заголовки = Новый Соответствие();
    Заголовки.Вставить("X-Vault-Token", Токен);

    HTTPЗапрос = Новый HTTPЗапрос(URL, Заголовки);
    
    Попытка
        Ответ = Соединение.ВызватьHTTPМетод("GET", HTTPЗапрос);

        Если Ответ.КодСостояния = 200 Тогда
            ТелоОтвета = Ответ.ПолучитьТелоКакСтроку();
            
            Если Найти(ТелоОтвета, """sealed"":true") <> 0 Тогда
                Сообщить("Хранилище запечатано. Открываю форму для ввода ключа.");
                ОткрытьФормуВводаКлюча();
            Иначе
                Сообщить("Хранилище открыто и готово к работе.");
            КонецЕсли;

        Иначе
            Сообщить("Ошибка запроса: " + Ответ.КодСостояния);
        КонецЕсли;
    Исключение
        Сообщить("Ошибка выполнения запроса: " + ОписаниеОшибки());
    КонецПопытки;
КонецПроцедуры

&НаСервере
Функция ПолучитьТокен() Экспорт
    Возврат Константы.ТокенVault.Получить(); 
КонецФункции

&НаКлиенте
Процедура ОткрытьФормуВводаКлюча()
    ФормаВвода = ОткрытьФорму("ОбщаяФорма.ФормаРаспечаткиХранилища");
КонецПроцедуры

&НаКлиенте
Процедура КнопкаЗапечататьНажатие(Команда)
    
    // Получаем токен из константы
    Токен1 = ПолучитьТокен1();  // Получаем токен из константы

    URL = "/v1/sys/seal";
    Соединение = Новый HTTPСоединение("10.0.0.11", 8200);
    
    Заголовки = Новый Соответствие();
    Заголовки.Вставить("X-Vault-Token", Токен1);  // Используем токен из константы

    HTTPЗапрос = Новый HTTPЗапрос(URL, Заголовки);
    
    Попытка
        Ответ = Соединение.ВызватьHTTPМетод("PUT", HTTPЗапрос);

        Если Ответ.КодСостояния = 204 Тогда
            Сообщить("Хранилище успешно запечатано.");
        Иначе
            Сообщить("Ошибка запечатывания: " + Ответ.КодСостояния);
        КонецЕсли;
    Исключение
        Сообщить("Ошибка выполнения запроса: " + ОписаниеОшибки());
    КонецПопытки;
КонецПроцедуры

&НаСервере
Функция ПолучитьТокен1() Экспорт
    Возврат Константы.ТокенVault.Получить(); 
КонецФункции

&НаСервере
Функция ЗаполнитьСтруктуруИзОтветаJSON(Знач Чтение) Экспорт
	Результат = Новый Структура;

	ПоследнееИмяРеквизита = Неопределено;
	
	Пока Чтение.Прочитать() Цикл
		Тип = Чтение.ТипТекущегоЗначения;
		Если Тип = ТипЗначенияJSON.НачалоОбъекта И ПоследнееИмяРеквизита<>Неопределено Тогда 
			Результат[ПоследнееИмяРеквизита] = ЗаполнитьСтруктуруИзОтветаJSON(Чтение);
		ИначеЕсли Тип = ТипЗначенияJSON.КонецОбъекта Тогда 
			Возврат Результат;
			ПоследнееИмяРеквизита = Неопределено;
		ИначеЕсли Тип = ТипЗначенияJSON.ИмяСвойства Тогда 
			Результат.Вставить(Чтение.ТекущееЗначение, Неопределено);
			ПоследнееИмяРеквизита = Чтение.ТекущееЗначение;
		ИначеЕсли Тип = ТипЗначенияJSON.Булево или Тип = ТипЗначенияJSON.Строка
			или Тип = ТипЗначенияJSON.Число или Тип = ТипЗначенияJSON.Null Тогда 
			Результат[ПоследнееИмяРеквизита] = Чтение.ТекущееЗначение;
		ИначеЕсли Тип = ТипЗначенияJSON.НачалоМассива Тогда 
			Результат[ПоследнееИмяРеквизита] = ЗаполнитьМассивИзОтветаJSON(Чтение);
		КонецЕсли;
	КонецЦикла;  
		
	Возврат Результат;
КонецФункции 

&НаСервере
Функция ЗаполнитьМассивИзОтветаJSON(Знач Чтение)
    Результат = Новый Массив;
    
    Пока Чтение.Прочитать() Цикл
        Тип = Чтение.ТипТекущегоЗначения;
        
        Если Тип = ТипЗначенияJSON.НачалоОбъекта Тогда 
            Результат.Добавить(ЗаполнитьСтруктуруИзОтветаJSON(Чтение));
        ИначеЕсли Тип = ТипЗначенияJSON.КонецМассива Тогда 
            Возврат Результат;
        ИначеЕсли Тип = ТипЗначенияJSON.Строка Или Тип = ТипЗначенияJSON.Число Тогда
            Результат.Добавить(Чтение.ТекущееЗначение);
        КонецЕсли;
    КонецЦикла;  

    Возврат Результат;
КонецФункции

&НаКлиенте
Процедура ПриИзмененииАдресХранилища(Элемент)
    ЭтаФорма.АдресХранилища = Элемент.Значение;
    СохранитьНастройкиНаСервере(ЭтаФорма.АдресХранилища, ЭтаФорма.ПортХранилища, ЭтаФорма.Токен);
КонецПроцедуры

Процедура ПриИзмененииПортХранилища(Элемент)
    ЭтаФорма.ПортХранилища = Элемент.Значение;
    СохранитьНастройкиНаСервере(ЭтаФорма.АдресХранилища, ЭтаФорма.ПортХранилища, ЭтаФорма.Токен);
КонецПроцедуры

Процедура ПриИзмененииТокен(Элемент)
    ЭтаФорма.Токен = Элемент.Значение;
    СохранитьНастройкиНаСервере(ЭтаФорма.АдресХранилища, ЭтаФорма.ПортХранилища, ЭтаФорма.Токен);
КонецПроцедуры

&НаСервере
Процедура СохранитьНастройкиНаСервере(АдресХранилища, ПортХранилища, Токен)
    Константы.АдресХранилища.Установить(АдресХранилища);
    Константы.ПортХранилища.Установить(ПортХранилища);
    Константы.ТокенVault.Установить(Токен);
КонецПроцедуры

&НаКлиенте
Процедура КнопкаИнициализацииНажатие(Команда)
    ТабДок = Новый ТабличныйДокумент;
    ИнициализироватьХранилищеVault(ТабДок);
    ТабДок.Показать();
КонецПроцедуры

&НаСервере
Процедура ВыполнитьVaultLoginИПрописатьПуть(Команда)
    Перем АдресХранилища, ПортХранилища, Токен, HTTPСоединение, HTTPЗапрос, Ответ, ТелоЗапроса;

    АдресХранилища = Константы.АдресХранилища.Получить();
    ПортХранилища = Константы.ПортХранилища.Получить();
    Токен = Константы.ТокенVault.Получить(); // Токен из константы

    // Логин в Vault с использованием токена
    HTTPСоединение = Новый HTTPСоединение(АдресХранилища, Число(ПортХранилища));
    HTTPЗапрос = Новый HTTPЗапрос("/v1/auth/token/login");

    Заголовки = Новый Соответствие();
    Заголовки.Вставить("X-Vault-Token", Токен);

    Ответ = HTTPСоединение.ВызватьHTTPМетод("POST", HTTPЗапрос);
    Если Ответ.КодСостояния = 200 Тогда
        Сообщить("Успешно выполнили Vault login.");

        // Прописываем секретный путь
        ТелоЗапроса = "{ ""type"": ""kv"", ""options"": { ""version"": ""2"" }}";
        HTTPЗапрос = Новый HTTPЗапрос("/v1/sys/mounts/secret");
        HTTPЗапрос.УстановитьТелоИзСтроки(ТелоЗапроса, "UTF-8");
        Ответ = HTTPСоединение.ВызватьHTTPМетод("POST", HTTPЗапрос);
        
        Если Ответ.КодСостояния = 200 Тогда
            Сообщить("Секретный путь успешно прописан.");
        Иначе
            Сообщить("Ошибка при прописывании секретного пути: " + Ответ.КодСостояния);
        КонецЕсли;
    Иначе
        Сообщить("Ошибка при выполнении Vault login: " + Ответ.КодСостояния);
    КонецЕсли;
КонецПроцедуры

&НаКлиенте
Процедура ВыборПользователяПриИзменении(Элемент)
    Если НЕ ЗначениеЗаполнено(ЭтотОбъект.ВыбранныйПользователь) Тогда
        Сообщить("Пользователь не выбран.");
        Возврат;
    КонецЕсли;

    НовыйUID = ПроверитьИГенерироватьUID(ЭтотОбъект.ВыбранныйПользователь);

    Если НовыйUID = Неопределено Тогда
        Сообщить("Ошибка при генерации UID.");
    Иначе
        Сообщить("UID пользователя: " + НовыйUID);
        
        // Передаем UID для создания политики и генерации токена
        Результат = СоздатьПолитикуИГенерироватьТокен(НовыйUID);  // Передаем НовыйUID
        Если Результат Тогда
            Сообщить("Политика и токен успешно созданы для пользователя.");
        Иначе
            Сообщить("Ошибка при создании политики или генерации токена.");
        КонецЕсли;
    КонецЕсли;
КонецПроцедуры

&НаКлиенте
Процедура ОткрытьФорму4()
    Если НЕ ЗначениеЗаполнено(UIDПользователя) Тогда
        UIDПользователя = Новый УникальныйИдентификатор(); // Установить начальное значение, если пусто
    КонецЕсли;
КонецПроцедуры

&НаСервере    
Функция ПроверитьИГенерироватьUID(СсылкаНаПользователя) Экспорт
    Если СсылкаНаПользователя = Неопределено Тогда
        Возврат Неопределено;
    КонецЕсли;

    Пользователь = СсылкаНаПользователя.ПолучитьОбъект(); 
    Если НЕ ЗначениеЗаполнено(Пользователь.UIDПользователя) Тогда
        // Генерируем UID, если он не существует
        Пользователь.UIDПользователя = Новый УникальныйИдентификатор();
        Попытка
            Пользователь.Записать();
        Исключение
            Возврат Неопределено;
        КонецПопытки;
    КонецЕсли;

    Возврат Пользователь.UIDПользователя;
КонецФункции


&НаКлиенте
Процедура ПолучитьТокенНажатие(Команда)
    Если НЕ ЗначениеЗаполнено(ВыбранныйПользователь) Тогда
        Сообщить("Выберите пользователя из списка.");
        Возврат;
    КонецЕсли;

    // Получаем объект пользователя, если это ссылка на элемент справочника
    Пользователь = ВыбранныйПользователь.ПолучитьОбъект();
    
    Если НЕ ЗначениеЗаполнено(Пользователь) Тогда
        Сообщить("Пользователь не найден.");
        Возврат;
    КонецЕсли;

    // Получаем UID пользователя
    UIDПользователя = Пользователь.UIDПользователя;

    Если НЕ ЗначениеЗаполнено(UIDПользователя) Тогда
        Сообщить("UID пользователя не найден.");
        Возврат;
    КонецЕсли;

    // Вызов серверной функции для получения полного объекта пользователя
    ПолныйПользователь = ПолучитьПользователяПоUID(UIDПользователя);

    Если ПолныйПользователь = Неопределено Тогда
        Сообщить("Ошибка загрузки данных пользователя.");
        Возврат;
    КонецЕсли;

    // Передаем UID для генерации токена
    Токен = ГенерироватьТокенДляПользователя(ПолныйПользователь.UIDПользователя);
    
    Если Токен <> "" Тогда
        Сообщить("Сгенерированный токен: " + Токен);
    Иначе
        Сообщить("Ошибка генерации токена.");
    КонецЕсли;
КонецПроцедуры

&НаСервере
Функция ПолучитьПользователяПоUID(UIDПользователя) Экспорт
    // Поиск пользователя по UID
    Пользователь = Справочники.Пользователи.НайтиПоРеквизиту("UIDПользователя", UIDПользователя);

    Если Пользователь = Неопределено Тогда
        Сообщить("Пользователь с UID " + Строка(UIDПользователя) + " не найден.");
        Возврат Неопределено;
    КонецЕсли;

    // Возвращаем объект пользователя
    Возврат Пользователь;
КонецФункции

&НаСервере
Функция ГенерироватьТокенДляПользователя(UIDПользователя) Экспорт
    // Поиск пользователя по UID
    Пользователь = Справочники.Пользователи.НайтиПоРеквизиту("UIDПользователя", UIDПользователя);

    Если Пользователь = Неопределено Тогда
        Сообщить("Пользователь с UID " + Строка(UIDПользователя) + " не найден.");
        Возврат "";
    КонецЕсли;

    // Получаем объект пользователя
    ОбъектПользователя = Пользователь.ПолучитьОбъект();

    Если НЕ ЗначениеЗаполнено(ОбъектПользователя.UIDПользователя) Тогда
        Сообщить("UID пользователя пустой, проверьте данные.");
        Возврат "";
    КонецЕсли;

    // Проверка на наличие токена
    Если ЗначениеЗаполнено(ОбъектПользователя.Токен) Тогда
        Сообщить("Токен уже существует для пользователя: " + ОбъектПользователя.Наименование);
        Возврат ОбъектПользователя.Токен;
    КонецЕсли;

    // Подготовка подключения к Vault для генерации токена
    ТокенVault = Константы.ТокенVault.Получить(); 
    АдресСервера = Константы.АдресХранилища.Получить(); 
    ПортСервера = Константы.ПортХранилища.Получить(); 

    Соединение = Новый HTTPСоединение(АдресСервера, Число(ПортСервера));
    Заголовки = Новый Соответствие();
    Заголовки.Вставить("X-Vault-Token", ТокенVault);
    Заголовки.Вставить("Content-Type", "application/json");

    // Формирование политики доступа
    НазваниеПолитики = "policy_" + ОбъектПользователя.UIDПользователя;
    ПутьКПолитике = "secret/data/" + ОбъектПользователя.UIDПользователя + "/*";
    ПраваПолитики = "read";

    ДанныеЗапросаПолитики = "{""policy"": ""path \""" + ПутьКПолитике + " { capabilities = [\""" + ПраваПолитики + "\""] }""}";

    Попытка
        // Создание политики в Vault
        HTTPЗапрос = Новый HTTPЗапрос("/v1/sys/policies/acl/" + НазваниеПолитики, Заголовки);
        HTTPЗапрос.УстановитьТелоИзСтроки(ДанныеЗапросаПолитики);
        Ответ = Соединение.ВызватьHTTPМетод("POST", HTTPЗапрос);

        Если Ответ.КодСостояния <> 204 Тогда
            Сообщить("Ошибка создания политики: Код " + Ответ.КодСостояния);
            Возврат "";
        КонецЕсли;
    Исключение
        Сообщить("Ошибка при создании политики: " + ОписаниеОшибки());
        Возврат "";
    КонецПопытки;

    // Генерация токена
    ДанныеЗапросаТокена = "{""policies"": [""" + НазваниеПолитики + """]}";
    Попытка
        HTTPЗапрос = Новый HTTPЗапрос("/v1/auth/token/create", Заголовки);
        HTTPЗапрос.УстановитьТелоИзСтроки(ДанныеЗапросаТокена);
        Ответ = Соединение.ВызватьHTTPМетод("POST", HTTPЗапрос);

        Если Ответ.КодСостояния = 200 Тогда
            ТелоОтвета = Ответ.ПолучитьТелоКакСтроку();
            ЧитательJSON = Новый ЧтениеJSON;
            ЧитательJSON.УстановитьСтроку(ТелоОтвета);
            ДанныеОтвета = ПрочитатьJSON(ЧитательJSON);

            Если ДанныеОтвета.Свойство("auth") Тогда
                НовыйТокен = ДанныеОтвета.auth.client_token;

                // Сохранение токена в объекте пользователя
                ОбъектПользователя.Токен = НовыйТокен;
                Попытка
                    ОбъектПользователя.Записать();
                    Сообщить("Токен сохранен для пользователя: " + ОбъектПользователя.Наименование + НовыйТокен ); 
                Исключение
                    Сообщить("Ошибка при сохранении токена: " + ОписаниеОшибки());
                КонецПопытки;

                Возврат НовыйТокен;
            КонецЕсли;
        Иначе
            Сообщить("Ошибка создания токена: Код " + Ответ.КодСостояния);
        КонецЕсли;
    Исключение
        Сообщить("Ошибка при создании токена: " + ОписаниеОшибки());
    КонецПопытки;

    Возврат "";
КонецФункции

&НаСервере
Функция ГенерироватьТокенДляПользователя2(UIDПользователя) Экспорт
    // Получаем запись пользователя по UID
    Пользователь = Справочники.Пользователи.НайтиПоРеквизиту("UIDПользователя", UIDПользователя);
    Если Пользователь = Неопределено Тогда
        Сообщить("Пользователь с UID " + UIDПользователя + " не найден.");
        Возврат "";
    КонецЕсли;

    // Диагностика: Выводим UID и токен пользователя
    Сообщить("UID для пользователя: " + Пользователь.UIDПользователя);
    Если ЗначениеЗаполнено(Пользователь.Токен) Тогда
        Сообщить("Токен уже существует: " + Пользователь.Токен);
    Иначе
        Сообщить("Токен для пользователя отсутствует.");
    КонецЕсли;

    // Проверяем, есть ли у пользователя уже токен
    Если ЗначениеЗаполнено(Пользователь.Токен) Тогда
        Сообщить("Токен уже существует для пользователя: " + Пользователь.Наименование);
        Возврат Пользователь.Токен;
    КонецЕсли;

    // Параметры подключения к Vault
    Токен = Константы.ТокенVault.Получить(); 
    АдресСервера = Константы.АдресХранилища.Получить(); 
    ПортСервера = Константы.ПортХранилища.Получить(); 
    Соединение = Новый HTTPСоединение(АдресСервера, Число(ПортСервера));

    Заголовки = Новый Соответствие();
    Заголовки.Вставить("X-Vault-Token", Токен);
    Заголовки.Вставить("Content-Type", "application/json");

    НазваниеПолитики = "policy_" + UIDПользователя;
    ПутьКПолитике = "secret/data/" + UIDПользователя + "/*";
    ПраваПолитики = "read";

    ДанныеЗапросаПолитики = "{""policy"": ""path \""" + ПутьКПолитике + " { capabilities = [\""" + ПраваПолитики + "\""] }""}";
    HTTPЗапрос = Новый HTTPЗапрос("/v1/sys/policies/acl/" + НазваниеПолитики, Заголовки);
    HTTPЗапрос.УстановитьТелоИзСтроки(ДанныеЗапросаПолитики);
	
    Попытка
        Ответ = Соединение.ВызватьHTTPМетод("POST", HTTPЗапрос);
        Если Ответ.КодСостояния <> 204 Тогда
            Сообщить("Ошибка создания политики: " + Ответ.КодСостояния);
            Возврат "";
        КонецЕсли;
    Исключение
        Сообщить("Ошибка при создании политики: " + ОписаниеОшибки());
        Возврат "";
    КонецПопытки;

    // Генерация токена для пользователя
    ДанныеЗапросаТокена = "{""policies"": [""" + НазваниеПолитики + """]}";
    HTTPЗапрос = Новый HTTPЗапрос("/v1/auth/token/create", Заголовки);
    HTTPЗапрос.УстановитьТелоИзСтроки(ДанныеЗапросаТокена);

    Попытка
        Ответ = Соединение.ВызватьHTTPМетод("POST", HTTPЗапрос);
        Если Ответ.КодСостояния = 200 Тогда
            ТелоОтвета = Ответ.ПолучитьТелоКакСтроку();
            ЧитательJSON = Новый ЧтениеJSON;
            ЧитательJSON.УстановитьСтроку(ТелоОтвета);
            ДанныеОтвета = ПрочитатьJSON(ЧитательJSON);

            Если ДанныеОтвета.Свойство("auth") Тогда
                НовыйТокен = ДанныеОтвета.auth.client_token;

                // Сохраняем токен в справочник
                Пользователь.Токен = НовыйТокен;
                Пользователь.Записать();
                Сообщить("Токен сохранен для пользователя: " + Пользователь.Наименование);

                Возврат НовыйТокен;
            КонецЕсли;
        Иначе
            Сообщить("Ошибка создания токена: " + Ответ.КодСостояния);
        КонецЕсли;
    Исключение
        Сообщить("Ошибка при создании токена: " + ОписаниеОшибки());
    КонецПопытки;

    Возврат "";
КонецФункции

&НаСервере
Процедура ПередЗаписью(Отказ, Режим)
    Если НЕ ЗначениеЗаполнено(UIDПользователя) Тогда
        ЭтотОбъект.UIDПользователя = Новый УникальныйИдентификатор();
    КонецЕсли;
КонецПроцедуры      


&НаСервере
Функция ПроверитьТокен(Токен) Экспорт
    URL = "/v1/auth/token/lookup-self";
    Соединение = Новый HTTPСоединение(Константы.АдресХранилища.Получить(), Число(Константы.ПортХранилища.Получить()));
    
    Заголовки = Новый Соответствие();
    Заголовки.Вставить("X-Vault-Token", Токен);

    HTTPЗапрос = Новый HTTPЗапрос(URL, Заголовки);

    Ответ = Соединение.ВызватьHTTPМетод("GET", HTTPЗапрос);

    Если Ответ.КодСостояния = 200 Тогда
        Возврат Истина;
    Иначе
        Сообщить("Ошибка: Неверный токен.");
        Возврат Ложь;
    КонецЕсли;
КонецФункции

&НаКлиенте
Процедура ПроверитьТокенНажатие(Команда)
    Токен = ПолучитьТокен();
    Если Токен <> "" Тогда
        Ответ = ПроверитьТокен(Токен);
        Если Ответ Тогда
            Сообщить("Токен действителен.");
        Иначе
            Сообщить("Ошибка: Неверный токен.");
        КонецЕсли;
    Иначе
        Сообщить("Ошибка: Токен не найден.");
    КонецЕсли;
КонецПроцедуры




&НаСервере
Функция СоздатьПолитикуИГенерироватьТокен(UIDПользователя) Экспорт
    Если НЕ ЗначениеЗаполнено(UIDПользователя) Тогда
        Сообщить("UID пользователя не задан.");
        Возврат Ложь;
    КонецЕсли;

    // 1. Создание политики в Vault
    ТокенVault = Константы.ТокенVault.Получить(); 
    АдресСервера = Константы.АдресХранилища.Получить(); 
    ПортСервера = Константы.ПортХранилища.Получить(); 

    Соединение = Новый HTTPСоединение(АдресСервера, Число(ПортСервера));
    Заголовки = Новый Соответствие();
    Заголовки.Вставить("X-Vault-Token", ТокенVault);
    Заголовки.Вставить("Content-Type", "application/json");

    // Формируем данные для политики
    НазваниеПолитики = "policy_" + UIDПользователя;
    ПутьКПолитике = "secret/data/*\""";
    ПраваПолитики = "read";
	ДанныеЗапросаПолитики = "{""policy"": ""path \""" + ПутьКПолитике + " { capabilities = [\""" + ПраваПолитики + "\""] }""}"; 
	
	
	
	HTTPЗапрос = Новый HTTPЗапрос("/v1/sys/policies/acl/" + НазваниеПолитики, Заголовки);	
	HTTPЗапрос.УстановитьТелоИзСтроки(ДанныеЗапросаПолитики);
    Попытка
        //HTTPЗапрос.УстановитьТелоИзСтроки(ДанныеЗапросаПолитики);
        Ответ = Соединение.ВызватьHTTPМетод("POST", HTTPЗапрос);

        Если Ответ.КодСостояния <> 204 Тогда
            Сообщить("Ошибка создания политики: Код " + Ответ.КодСостояния);
            Возврат Ложь;
        КонецЕсли;
    Исключение
        Сообщить("Ошибка при создании политики: " + ОписаниеОшибки());
        Возврат Ложь;
    КонецПопытки;

    // 2. Генерация токена для пользователя
    Пользователь = Справочники.Пользователи.НайтиПоРеквизиту("UIDПользователя", UIDПользователя);
    Если Пользователь = Неопределено Тогда
        Сообщить("Пользователь с UID " + Строка(UIDПользователя) + " не найден.");
        Возврат Ложь;
    КонецЕсли;

    // Загружаем объект пользователя для работы с полями
    ОбъектПользователя = Пользователь.ПолучитьОбъект();

    Если НЕ ЗначениеЗаполнено(ОбъектПользователя.UIDПользователя) Тогда
        Сообщить("UID пользователя пустой, проверьте данные.");
        Возврат Ложь;
    КонецЕсли;

    // Если токен уже существует, возвращаем его
    Если ЗначениеЗаполнено(ОбъектПользователя.Токен) Тогда
        Сообщить("Токен уже существует для пользователя: " + ОбъектПользователя.Наименование);
        Возврат Истина;
    КонецЕсли;

    // Генерация токена в Vault
    ДанныеЗапросаТокена = "{""policies"": [""" + НазваниеПолитики + """]}";
    Попытка
        HTTPЗапрос = Новый HTTPЗапрос("/v1/auth/token/create", Заголовки);
        HTTPЗапрос.УстановитьТелоИзСтроки(ДанныеЗапросаТокена);
        Ответ = Соединение.ВызватьHTTPМетод("POST", HTTPЗапрос);

        Если Ответ.КодСостояния = 200 Тогда
            ТелоОтвета = Ответ.ПолучитьТелоКакСтроку();
            ЧитательJSON = Новый ЧтениеJSON;
            ЧитательJSON.УстановитьСтроку(ТелоОтвета);
            ДанныеОтвета = ПрочитатьJSON(ЧитательJSON);

            Если ДанныеОтвета.Свойство("auth") Тогда
                НовыйТокен = ДанныеОтвета.auth.client_token;

                // Сохранение токена в справочник
                ОбъектПользователя.Токен = НовыйТокен;
                Попытка
                    ОбъектПользователя.Записать();
                    Сообщить("Токен сохранен для пользователя: " + ОбъектПользователя.Наименование + НовыйТокен);
                Исключение
                    Сообщить("Ошибка при сохранении токена: " + ОписаниеОшибки());
                КонецПопытки;

                Возврат Истина;
            КонецЕсли;
        Иначе
            Сообщить("Ошибка создания токена: Код " + Ответ.КодСостояния);
        КонецЕсли;
    Исключение
        Сообщить("Ошибка при создании токена: " + ОписаниеОшибки());
    КонецПопытки;

    Возврат Ложь;
КонецФункции








